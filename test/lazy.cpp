//---------------------------------------------------------------------------
#include "stdafx.h"
//---------------------------------------------------------------------------
#include "lazymatr.h"
#include <iostream>
//---------------------------------------------------------------------------
int _tmain(int argc, _TCHAR* argv[])
{	
	///векторные и матричные операции на основе отложенных вычислений
	/*
	///1. инициализация, вывод в поток, сравнение
	{
		Matrix3x3f m, m2; Vector4i v;
		///если кол-во значений превышает размерность матрицы или вектора
		///будет ошибка компиляции
		m << 1.0f, 2.0f, 3.0f,
			 4.0f, 5.0f, 6.0f,
			 7.0f, 8.0f, 9.0f;

		v << 1,2,3,4;

		std::cout << m << v << std::endl;
		///заполнить нулями все элементы
		m.zero();	v.zero();
		std::cout << m << v << std::endl;
		///еденичная матрица
		m.identity();
		std::cout << m << std::endl;

		///определены операции для поэлементного сравнения матриц == и != 
		m2 << 1.1f, 2.2f, 3.3f,
			  4.4f, 5.5f, 6.6f,
			  7.5f, 8.6f, 9.7f;	

		if(m != m2)
			std::cout << "m != m2" << std::endl;
		
		///определены операции для поэлементного сравнения с константой > < и ф-ия abslt (меньше по абсолютному значение)
		if( m > 0.0f && m2 < 15.0f)
			std::cout << "m > 0.0f && m2 < 15.0f"  << std::endl;

	}

	///2. Векторные операции
	///Соответствие размерностей всех векторов в выражениях проверяются в compile time
	{
		Vector3f a,b,c,d;

		a << 1.0f,2.0f,3.0f;
		b << 5.0f,6.0f,7.0f;

		float dot = a | b;	///<скалярное произведение
		c = a ^ b;			///<векторное произведение		

		d = 5.0f * (c ^ a) + (a | c) - a * b;
		
		///все операции кроме векторного произведения определены
		///для векторов произвольной размерности
		Vector10f e,f,g;

		e << 1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f, 9.0f, 10.0f;
		f = e;

		dot = e | f;
		g = e + f - dot;

		///сумма квадратов элементов вектора
		float s = e.sqrSum();
		///длина вектора
		float l = f.length();
		///нормализация
		g.normalize();///<нормализует g
	}

	///3. Матричные операции
	///Соответствие размерностей всех матриц в выражениях проверяются в compile time
	{
		Matrix3x3f m3x3,a,b;
		Matrix2x3f m2x3;	m2x3 << 1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f;
		Matrix3x2f m3x2;	m3x2 << 5.0f, 4.0f, 3.0f, 2.0f, 1.0f, 0.0f;
		
		///умножение
		m3x3 = 3.0f * m3x2 * m2x3;///<!!!!!Не ипользуйте больше одной операции матричного 
		///умножения в выражении, Очень большой overhead! 
		///Подробности http://www.gamedev.ru/forum/?group=2&topic=1661&page=3 пост 42


		a << 9.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f, 9.0f;
		b << 9.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f, 9.0f;

		///обращение матриц
		m3x3 = b * inverse(a);///<обращает a и возвращает ее по ссылке. Проверка на сингулярность assert-ом
		std::cout << m3x3 << std::endl;

		if(inverseif(a))///<обращает a если определитель не ноль и возвращает false, в противном случае возвращает true.
			std::cout << "Zero determinant!" << std::endl;

		///для матриц 4х4, кот. являются комбинацией поворотов и сдвигов можно использовать
		///более быстрый алгоритм обращения, использующий  эту особенность
		Matrix4x4f ma, mb, res;
			
		ma << 0.57487148f,	0.20136166f,	0.79308027f,	0.0f,
			 -0.78165251f,	0.42174986f,	0.45950660f,	0.0f,
			 -0.24195445f,	-0.88407046f,	0.39984691f,	0.0f,
			 0.0f,			0.0f,			-316.22778f,	1.0f;

		mb = ma;

		res = inverseAffine4x4(ma) * mb;///< res - единичная матрица

		std::cout << res << std::endl;
		
		///транспонирование		
		Matrix3x2f m1;	m1 << 1.0f,2.0f,3.0f,4.0f,5.0f,6.0f;
		Matrix2x3f m2;		

		m2 = m1.transpose();

		std::cout << m1 << m2 << std::endl;

		///можно вытащить строку или столбец
		std::cout << b.getRow(0) << b.getCol(1) << std::endl;

		///составные выражения
		m3x3 = 3.0f * m3x2 * m2x3 - inverse(a) + b.transpose();
	}

	

	///Можно определить матрицу или вектор произвольной размерности 
	///например след. образом (только без фанатизма :) )
	TYPEDEF_VECTOR(20,long double) Vector20ld;
	TYPEDEF_MATRIX(15,4,unsigned int) Matrix15x4ui;

	*/

	return 0;
}